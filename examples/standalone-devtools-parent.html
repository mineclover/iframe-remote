<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DevTools Parent - Standalone (file:// compatible)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 { color: #333; }
    .container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }
    .section {
      background: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .full-width {
      grid-column: 1 / -1;
    }
    button {
      margin: 5px;
      padding: 10px 20px;
      font-size: 14px;
      cursor: pointer;
      background: #007acc;
      color: white;
      border: none;
      border-radius: 4px;
    }
    button:hover { background: #005a9e; }
    button:disabled { background: #ccc; cursor: not-allowed; }
    input {
      padding: 8px;
      margin: 5px;
      width: 200px;
    }
    iframe {
      width: 100%;
      height: 400px;
      border: 2px solid #ddd;
      border-radius: 4px;
    }
    .functions-list {
      max-height: 300px;
      overflow-y: auto;
      background: #f9f9f9;
      padding: 10px;
      border-radius: 4px;
      margin-top: 10px;
    }
    .function-item {
      padding: 8px;
      margin: 4px 0;
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .function-item:hover {
      background: #e3f2fd;
      border-color: #007acc;
    }
    .function-item.selected {
      background: #bbdefb;
      border-color: #0066cc;
    }
    .function-name {
      font-weight: bold;
      color: #0066cc;
      font-family: 'Courier New', monospace;
    }
    .function-type {
      color: #666;
      font-size: 12px;
      margin-left: 10px;
    }
    .result {
      margin-top: 15px;
      padding: 15px;
      background: #f9f9f9;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      max-height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .result.success {
      background: #e8f5e9;
      border-color: #4caf50;
    }
    .result.error {
      background: #ffebee;
      border-color: #f44336;
      color: #c62828;
    }
    .log-section {
      margin-top: 10px;
      padding: 10px;
      background: #f0f0f0;
      border-radius: 4px;
      max-height: 200px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 11px;
    }
    .log-entry {
      padding: 4px;
      margin: 2px 0;
      border-left: 3px solid #ccc;
      padding-left: 8px;
    }
    .log-entry.info { border-color: #2196f3; }
    .log-entry.success { border-color: #4caf50; }
    .log-entry.error { border-color: #f44336; }
    .status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 5px;
    }
    .status-indicator.connected { background: #4caf50; }
    .status-indicator.disconnected { background: #f44336; }
    .args-input {
      display: flex;
      gap: 10px;
      margin: 10px 0;
      align-items: center;
    }
  </style>
</head>
<body>
  <h1>üöÄ DevTools Parent - Remote Function Execution (file://)</h1>

  <div style="padding: 10px; background: white; border-radius: 4px; margin-bottom: 10px;">
    <strong>Connection Status:</strong>
    <span class="status-indicator" id="status-indicator"></span>
    <span id="status-text">Initializing...</span>
  </div>

  <div class="container">
    <div class="section">
      <h3>üìã Available Functions</h3>
      <button id="refresh-btn">üîÑ Refresh List</button>
      <div class="functions-list" id="functions-list">
        <em>Loading...</em>
      </div>
    </div>

    <div class="section">
      <h3>‚ö° Execute Function</h3>
      <div>
        <strong>Selected:</strong> <span id="selected-function">None</span>
      </div>
      <div id="function-description" style="margin: 10px 0; padding: 10px; background: #f0f0f0; border-radius: 4px; display: none;">
        <em id="description-text"></em>
      </div>
      <div id="auto-inputs" style="margin: 10px 0;"></div>
      <div class="args-input">
        <input type="text" id="args-input" placeholder='Arguments as JSON: [1, "test"]' style="flex: 1;">
        <button id="execute-btn" disabled>Execute</button>
      </div>
      <div>
        <strong>Quick Execute:</strong><br>
        <button onclick="quickCall('__getUserInfo', [])">getUserInfo()</button>
        <button onclick="quickCall('__getPageData', [])">getPageData()</button>
        <button onclick="quickCall('__add', [5, 3])">add(5, 3)</button>
        <button onclick="quickCall('__getRandomNumber', [1, 100])">getRandomNumber(1, 100)</button>
        <button onclick="quickCall('__asyncOperation', [500])">asyncOperation(500ms)</button>
      </div>
      <div class="result" id="result">
        <em>No execution yet</em>
      </div>
      <div>
        <strong>Communication Log:</strong>
        <button onclick="clearLog()" style="float:right;padding:5px 10px;font-size:11px;">Clear</button>
      </div>
      <div class="log-section" id="log-section"></div>
    </div>
  </div>

  <div class="section full-width">
    <h3>üì∫ Child Iframe</h3>
    <iframe id="child-iframe" src="./standalone-devtools-child.html"></iframe>
  </div>

  <script>
    // Inlined ParentRPC and ParentDevTools implementation
    class RPCError extends Error {
      constructor(message, code) {
        super(message)
        this.name = 'RPCError'
        this.code = code
      }
    }

    class ParentRPC {
      constructor(targetWindow, options = {}) {
        this.targetWindow = targetWindow
        this.targetOrigin = options.targetOrigin || '*'
        this.handlers = new Map()
        this.pendingCalls = new Map()

        this.messageHandler = (event) => {
          if (this.targetOrigin !== '*' && event.origin !== this.targetOrigin) return
          if (event.source !== this.targetWindow) return
          this.handleMessage(event.data)
          options.onMessage?.(event.data)
        }

        window.addEventListener('message', this.messageHandler)
      }

      handleMessage(data) {
        if (data.type === 'rpc-response') {
          this.handleResponse(data)
        } else if (data.type === 'rpc-call') {
          this.handleCall(data)
        }
      }

      handleResponse(response) {
        const pending = this.pendingCalls.get(response.id)
        if (!pending) return

        clearTimeout(pending.timeout)
        this.pendingCalls.delete(response.id)

        if (response.success) {
          pending.resolve(response.result)
        } else {
          pending.reject(new RPCError(response.error || 'RPC call failed'))
        }
      }

      async handleCall(call) {
        const handler = this.handlers.get(call.method)

        if (!handler) {
          this.sendResponse(call.id, false, undefined, `Method not found: ${call.method}`)
          return
        }

        try {
          const result = await handler(...call.args)
          this.sendResponse(call.id, true, result)
        } catch (error) {
          this.sendResponse(call.id, false, undefined, error.message)
        }
      }

      sendResponse(id, success, result, error) {
        const response = {
          type: 'rpc-response',
          id,
          success,
          result,
          error,
          timestamp: Date.now(),
        }
        this.targetWindow.postMessage(response, this.targetOrigin)
      }

      register(method, handler) {
        this.handlers.set(method, handler)
      }

      call(method, ...args) {
        return new Promise((resolve, reject) => {
          const id = `rpc-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
          const timeoutHandle = setTimeout(() => {
            this.pendingCalls.delete(id)
            reject(new RPCError('RPC call timeout', 'TIMEOUT'))
          }, 5000)

          this.pendingCalls.set(id, { resolve, reject, timeout: timeoutHandle })

          const message = {
            type: 'rpc-call',
            id,
            method,
            args,
            timestamp: Date.now(),
          }

          this.targetWindow.postMessage(message, this.targetOrigin)
        })
      }

      destroy() {
        window.removeEventListener('message', this.messageHandler)
        this.handlers.clear()
        this.pendingCalls.forEach((pending) => {
          clearTimeout(pending.timeout)
          pending.reject(new RPCError('RPC destroyed'))
        })
        this.pendingCalls.clear()
      }
    }

    class ParentDevTools {
      constructor(targetWindow, options = {}) {
        this.rpc = new ParentRPC(targetWindow, options)
      }

      async listFunctions() {
        return this.rpc.call('__devtools_list')
      }

      async callFunction(name, ...args) {
        return this.rpc.call('__devtools_call', name, ...args)
      }

      async refreshFunctions() {
        return this.rpc.call('__devtools_refresh')
      }

      destroy() {
        this.rpc.destroy()
      }
    }

    // UI Logic
    const iframe = document.getElementById('child-iframe')
    const functionsList = document.getElementById('functions-list')
    const selectedFunctionEl = document.getElementById('selected-function')
    const argsInput = document.getElementById('args-input')
    const executeBtn = document.getElementById('execute-btn')
    const resultEl = document.getElementById('result')
    const refreshBtn = document.getElementById('refresh-btn')
    const statusIndicator = document.getElementById('status-indicator')
    const statusText = document.getElementById('status-text')
    const logSection = document.getElementById('log-section')

    let devtools
    let selectedFunction = null
    let availableFunctions = []

    function setStatus(connected, text) {
      statusIndicator.className = `status-indicator ${connected ? 'connected' : 'disconnected'}`
      statusText.textContent = text
    }

    function addLog(message, type = 'info') {
      const entry = document.createElement('div')
      entry.className = `log-entry ${type}`
      const time = new Date().toLocaleTimeString()
      entry.textContent = `[${time}] ${message}`
      logSection.appendChild(entry)
      logSection.scrollTop = logSection.scrollHeight
    }

    window.clearLog = function() {
      logSection.innerHTML = ''
    }

    function showResult(data, isError = false) {
      resultEl.className = `result ${isError ? 'error' : 'success'}`
      resultEl.textContent = JSON.stringify(data, null, 2)

      if (isError) {
        addLog(`‚ùå Error: ${data.error}`, 'error')
      } else {
        addLog(`‚úÖ Success: ${JSON.stringify(data).substring(0, 100)}...`, 'success')
      }
    }

    function showError(error) {
      showResult({
        error: error.message,
        stack: error.stack
      }, true)
    }

    function selectFunction(fn) {
      selectedFunction = fn
      selectedFunctionEl.textContent = fn.name
      executeBtn.disabled = false

      document.querySelectorAll('.function-item').forEach(item => {
        item.classList.toggle('selected', item.dataset.name === fn.name)
      })

      // Show description
      const descriptionDiv = document.getElementById('function-description')
      const descriptionText = document.getElementById('description-text')
      if (fn.description) {
        descriptionText.textContent = fn.description
        descriptionDiv.style.display = 'block'
      } else {
        descriptionDiv.style.display = 'none'
      }

      // Generate auto inputs based on paramsMeta
      generateAutoInputs(fn)
    }

    function inferParamType(param) {
      const name = param.name.toLowerCase()

      // Boolean Ìå®ÌÑ¥: is*, has*, should*, enabled, disabled, etc.
      if (/^(is|has|should|can|will|enable|disable|show|hide)/.test(name) ||
          /(enabled|disabled|visible|hidden|active)$/.test(name)) {
        return 'boolean'
      }

      // Number Ìå®ÌÑ¥: *count, *index, *number, *id, min*, max*, *size, *width, *height, etc.
      if (/^(min|max|num|count|index|id|size|width|height|length|delay|timeout|duration)/.test(name) ||
          /(count|number|index|id|size|width|height|length|delay|ms|px)$/.test(name)) {
        return 'number'
      }

      // Color Ìå®ÌÑ¥: *color, *colour
      if (/color|colour/.test(name)) {
        return 'color'
      }

      // Array Ìå®ÌÑ¥: *list, *array, *items, etc.
      if (/^(list|array|items|options|values)/.test(name) || /(list|array|items|s)$/.test(name)) {
        return 'array'
      }

      return 'text'
    }

    function generateAutoInputs(fn) {
      const autoInputsDiv = document.getElementById('auto-inputs')
      autoInputsDiv.innerHTML = ''

      // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏúºÎ©¥ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ ÌååÎùºÎØ∏ÌÑ∞ Ïù¥Î¶ÑÎßåÏúºÎ°ú ÏÉùÏÑ±
      const params = fn.paramsMeta && fn.paramsMeta.length > 0
        ? fn.paramsMeta
        : fn.params.map(p => ({ name: p.name, type: inferParamType(p) }))

      if (params.length === 0) {
        return
      }

      addLog(`üé® Generating ${params.length} input fields`, 'info')

      params.forEach((param, index) => {
        const wrapper = document.createElement('div')
        wrapper.style.cssText = 'margin: 8px 0; padding: 8px; background: #f9f9f9; border-radius: 4px;'

        const label = document.createElement('label')
        label.style.cssText = 'display: block; font-weight: bold; margin-bottom: 4px; font-size: 13px;'

        const inferredType = param.type || inferParamType(param)
        label.textContent = `${param.name} (${inferredType})`

        if (param.description) {
          const desc = document.createElement('div')
          desc.style.cssText = 'font-size: 11px; color: #666; margin-bottom: 4px;'
          desc.textContent = param.description
          wrapper.appendChild(desc)
        }

        let input
        let inputType = inferredType

        if (param.type === 'select' && param.options) {
          // Î™ÖÏãúÏ†Å select ÌÉÄÏûÖ
          input = document.createElement('select')
          param.options.forEach(opt => {
            const option = document.createElement('option')
            option.value = opt
            option.textContent = opt
            if (opt === param.default) option.selected = true
            input.appendChild(option)
          })
        } else if (inputType === 'boolean') {
          input = document.createElement('input')
          input.type = 'checkbox'
          input.checked = param.default !== undefined ? param.default : false
          input.style.cssText = 'width: auto; margin: 0;'
        } else if (inputType === 'number') {
          input = document.createElement('input')
          input.type = 'number'
          input.value = param.default !== undefined ? param.default : '0'
          if (param.min !== undefined) input.min = param.min
          if (param.max !== undefined) input.max = param.max
          input.step = 'any'
        } else if (inputType === 'color') {
          input = document.createElement('input')
          input.type = 'color'
          input.value = param.default || '#667eea'
        } else if (inputType === 'array') {
          input = document.createElement('input')
          input.type = 'text'
          input.placeholder = 'Enter JSON array: [1,2,3]'
          input.value = param.default ? JSON.stringify(param.default) : '[]'
        } else {
          input = document.createElement('input')
          input.type = 'text'
          input.value = param.default !== undefined ? param.default : ''
          input.placeholder = `Enter ${param.name}`
        }

        input.dataset.paramIndex = index
        input.dataset.paramName = param.name
        input.dataset.paramType = inputType
        input.style.cssText = input.type === 'checkbox'
          ? 'width: auto; margin: 0;'
          : 'padding: 6px; width: 100%; box-sizing: border-box; border: 1px solid #ddd; border-radius: 3px;'

        wrapper.appendChild(label)
        wrapper.appendChild(input)
        autoInputsDiv.appendChild(wrapper)
      })

      argsInput.placeholder = 'Auto-filled from inputs above (or enter JSON array)'
    }

    async function refreshFunctions() {
      try {
        refreshBtn.disabled = true
        refreshBtn.textContent = '‚è≥ Refreshing...'
        addLog('üì° Requesting function list from child...', 'info')

        availableFunctions = await devtools.refreshFunctions()
        addLog(`üìã Received ${availableFunctions.length} functions`, 'success')

        functionsList.innerHTML = ''

        if (availableFunctions.length === 0) {
          functionsList.innerHTML = '<em>No functions found</em>'
          return
        }

        availableFunctions.forEach(fn => {
          const item = document.createElement('div')
          item.className = 'function-item'
          item.dataset.name = fn.name

          // Format parameter list
          const paramList = fn.params && fn.params.length > 0
            ? fn.params.map(p => p.name).join(', ')
            : ''

          item.innerHTML = `
            <div>
              <span class="function-name">${fn.name}(${paramList})</span>
              <span class="function-type">${fn.type}</span>
            </div>
            ${fn.params && fn.params.length > 0 ?
              `<div style="font-size:10px;color:#666;margin-top:2px;">
                Parameters: ${fn.params.map(p => p.name).join(', ')}
              </div>` : ''}
          `
          item.addEventListener('click', () => selectFunction(fn))
          functionsList.appendChild(item)
        })

        showResult({
          message: `Found ${availableFunctions.length} functions`,
          functions: availableFunctions.map(f => f.name)
        })
      } catch (error) {
        addLog(`‚ùå Failed to refresh functions: ${error.message}`, 'error')
        showError(error)
      } finally {
        refreshBtn.disabled = false
        refreshBtn.textContent = 'üîÑ Refresh List'
      }
    }

    async function executeFunction() {
      if (!selectedFunction) return

      try {
        executeBtn.disabled = true
        executeBtn.textContent = '‚è≥ Executing...'

        let args = []
        const argsStr = argsInput.value.trim()

        // Try to use auto-generated inputs first
        const autoInputsDiv = document.getElementById('auto-inputs')
        const inputs = autoInputsDiv.querySelectorAll('input, select')

        if (inputs.length > 0 && !argsStr) {
          // Collect from auto-generated inputs
          inputs.forEach(input => {
            const type = input.dataset.paramType
            let value

            if (type === 'number') {
              value = parseFloat(input.value) || 0
            } else if (type === 'boolean') {
              value = input.checked
            } else if (type === 'array') {
              try {
                value = JSON.parse(input.value)
              } catch (e) {
                value = []
              }
            } else if (type === 'select' || type === 'color' || type === 'text') {
              value = input.value
            } else {
              value = input.value
            }

            args.push(value)
          })
        } else if (argsStr) {
          // Use JSON input
          args = JSON.parse(argsStr)
          if (!Array.isArray(args)) {
            throw new Error('Arguments must be an array')
          }
        }

        addLog(`üìû Calling ${selectedFunction.name}(${JSON.stringify(args)})`, 'info')
        const result = await devtools.callFunction(selectedFunction.name, ...args)

        showResult({
          function: selectedFunction.name,
          arguments: args,
          result
        })
      } catch (error) {
        addLog(`‚ùå Function call failed: ${error.message}`, 'error')
        showError(error)
      } finally {
        executeBtn.disabled = false
        executeBtn.textContent = 'Execute'
      }
    }

    window.quickCall = async function(fnName, args) {
      try {
        addLog(`üìû Quick call: ${fnName}(${JSON.stringify(args)})`, 'info')
        const result = await devtools.callFunction(fnName, ...args)
        showResult({
          function: fnName,
          arguments: args,
          result
        })
      } catch (error) {
        addLog(`‚ùå Quick call failed: ${error.message}`, 'error')
        showError(error)
      }
    }

    iframe.addEventListener('load', async () => {
      console.log('‚úÖ Iframe loaded, initializing DevTools...')
      addLog('üîÑ Initializing connection to child iframe...', 'info')
      setStatus(false, 'Connecting...')

      devtools = new ParentDevTools(iframe.contentWindow, {
        targetOrigin: '*'
      })

      await new Promise(resolve => setTimeout(resolve, 100))

      try {
        await refreshFunctions()
        setStatus(true, 'Connected')
        addLog('‚úÖ DevTools ready!', 'success')
      } catch (error) {
        setStatus(false, 'Connection failed')
        addLog(`‚ùå Initialization failed: ${error.message}`, 'error')
      }

      console.log('‚úÖ DevTools ready!')
      window.devtools = devtools
    })

    executeBtn.addEventListener('click', executeFunction)
    refreshBtn.addEventListener('click', refreshFunctions)

    argsInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        executeFunction()
      }
    })
  </script>
</body>
</html>
